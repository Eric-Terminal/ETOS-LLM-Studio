### Model Context Protocol (MCP) 技术规范文档

#### **1. 概述**

**1.1. 定义**
Model Context Protocol (MCP) 是一个开放的、标准化的技术框架，用于在 AI 主机应用程序（MCP Host）与外部服务（MCP Server）之间进行通信。

**1.2. 目标**
MCP 的核心目标是提供一个统一、可扩展的协议，使 AI 模型能够安全、高效地发现并调用外部工具（Tools）以及查询外部数据源（Resources），从而执行超越其内置能力的复杂任务。

**1.3. 范围**
本规范定义了 MCP 的架构、通信协议、传输机制、核心原语、标准方法以及安全模型。所有 MCP 兼容的实现都必须遵循本文档定义的规则。

#### **2. 核心架构**

MCP 采用客户端-服务器架构，包含以下三个逻辑组件：

*   **2.1. MCP Host (主机)**：运行 AI 模型的应用程序环境。主机是 MCP 连接的发起方和最终使用者。
*   **2.2. MCP Client (客户端)**：位于主机内部的逻辑组件。客户端负责管理与一个或多个 MCP Server 的连接，并严格按照本规范封装和解析通信消息。
*   **2.3. MCP Server (服务器)**：一个独立的外部服务进程。服务器负责向客户端暴露其拥有的工具和资源。服务器可以是本地进程，也可以是网络上的远程服务。

#### **3. 通信协议**

**3.1. 基础协议**
MCP 的所有通信都必须严格遵循 **JSON-RPC 2.0** 规范。所有消息体都必须是有效的 JSON 对象。

**3.2. 消息结构**

*   **3.2.1. 请求 (Request) 对象**
    一个向 Server 发送的请求对象必须包含以下字段：
    *   `jsonrpc`: (String) 必须是 `"2.0"`。
    *   `id`: (String | Integer | Null) 由客户端生成的唯一标识符。用于匹配响应。
    *   `method`: (String) 定义了要调用的方法名称。方法名称以 `mcp/` 为前缀的是本协议定义的标准方法。
    *   `params`: (Object | Array) 调用方法所需的参数。其结构由被调用的 `method` 定义。

*   **3.2.2. 响应 (Response) 对象**
    服务器对请求的响应对象必须包含以下字段：
    *   `jsonrpc`: (String) 必须是 `"2.0"`。
    *   `id`: (String | Integer | Null) 必须与对应的请求 `id` 相同。
    *   `result`: (Any) 当方法调用成功时，此字段必须存在。其内容由被调用的 `method` 定义。
    *   `error`: (Object) 当方法调用失败时，此字段必须存在。`result` 字段此时不得存在。

*   **3.2.3. 错误 (Error) 对象**
    当 `error` 字段存在时，它必须是一个包含以下字段的对象：
    *   `code`: (Integer) 错误码。
    *   `message`: (String) 错误的简短描述。
    *   `data`: (Any) 可选的、与错误相关的额外数据。

**3.3. 官方 Schema**
所有标准方法、参数和返回值的权威数据结构定义，均以 JSON Schema 的形式发布在 MCP 官方 GitHub 仓库中。实现方必须以此为准。

#### **4. 传输层**

MCP 客户端与服务器之间的 JSON-RPC 消息通过以下两种标准传输机制进行交换：

**4.1. Stdio (标准输入/输出)**

*   **4.1.1. 用途**：用于客户端和服务器在同一台机器上作为不同进程运行时进行本地通信。
*   **4.1.2. 消息帧**：Stdio 上的消息流必须使用类似 Language Server Protocol (LSP) 的方式进行分帧。每条 JSON-RPC 消息都必须在前面加上一个 ASCII 编码的头部，后跟消息本身。
    *   **头部格式**: `Content-Length: {size}\r\n\r\n`
    *   `{size}` 是指紧随其后的 JSON-RPC 消息内容的字节数。
    *   头部与消息内容之间必须由两个回车换行符 (`\r\n\r\n`) 分隔。
*   **4.1.3. 示例**：
    ```
    Content-Length: 134\r\n
    \r\n
    {"jsonrpc":"2.0","id":1,"method":"mcp/tool/execute","params":{"toolId":"filesystem/readFile","inputs":{"path":"/path/to/file.txt"}}}
    ```

**4.2. HTTP with Server-Sent Events (SSE)**

*   **4.2.1. 用途**：用于通过网络进行通信，支持服务器向客户端的流式响应。
*   **4.2.2. 普通请求/响应**：对于非流式的请求/响应，客户端必须向服务器的指定端点发送一个标准的 HTTP `POST` 请求。
    *   `Content-Type` 请求头必须是 `application/json`。
    *   请求体必须是单个 JSON-RPC 请求对象。
    *   服务器的响应体必须是单个 JSON-RPC 响应对象。
*   **4.2.3. 流式响应 (SSE)**：当方法支持流式响应时，客户端必须在请求头中包含 `Accept: text/event-stream`。
    *   服务器的 `Content-Type` 响应头必须是 `text/event-stream`。
    *   服务器必须以 SSE 事件流的形式发送一系列 JSON-RPC 响应。每个事件的 `data` 字段都包含一个完整的 JSON-RPC 响应对象。

#### **5. 核心原语与标准方法**

**5.1. 原语定义**

*   **5.1.1. Tool (工具)**：一个可由 AI 调用的、定义了输入和输出的可执行函数。
*   **5.1.2. Resource (资源)**：一个可供 AI 查询的、用于提供上下文信息的数据源。

**5.2. 标准方法**
所有 MCP Server 都必须实现以下标准方法，以确保互操作性。

*   **5.2.1. `mcp/initialize`**
    *   **描述**：客户端在建立连接后发送的第一个请求，用于协商能力。
    *   **`params`**: (Object) 包含客户端的能力信息，如支持的传输协议、认证信息等。
    *   **`result`**: (Object) 包含服务器的能力信息，如服务器名称、版本、支持的方法列表等。

*   **5.2.2. `mcp/listTools`**
    *   **描述**：客户端用于发现服务器所提供的所有可用工具。
    *   **`params`**: (Null | Object) 可为空。
    *   **`result`**: (Array) 一个对象数组，每个对象详细描述一个工具，包括 `toolId`、描述、输入参数的 JSON Schema 等。

*   **5.2.3. `mcp/listResources`**
    *   **描述**：客户端用于发现服务器所提供的所有可用资源。
    *   **`params`**: (Null | Object) 可为空。
    *   **`result`**: (Array) 一个对象数组，每个对象详细描述一个资源，包括 `resourceId`、描述、查询参数的 JSON Schema 等。

*   **5.2.4. `mcp/tool/execute`**
    *   **描述**：客户端用于执行一个指定的工具。
    *   **`params`**: (Object) 必须包含：
        *   `toolId`: (String) 要执行的工具的唯一标识符。
        *   `inputs`: (Object) 一个键值对对象，包含执行该工具所需的所有输入参数。
    *   **`result`**: (Any) 工具执行成功后的输出。其结构由该工具的定义决定。

*   **5.2.5. `mcp/resource/read`**
    *   **描述**：客户端用于读取一个指定的资源。
    *   **`params`**: (Object) 必须包含：
        *   `resourceId`: (String) 要读取的资源的唯一标识符。
        *   `query`: (Object) 可选，一个键值对对象，包含读取该资源所需的查询参数。
    *   **`result`**: (Any) 资源读取成功后的内容。其结构由该资源的定义决定。

#### **6. 安全模型**

**6.1. 认证**
MCP 推荐使用 **OAuth 2.0** 协议进行客户端与服务器之间的认证，以集成现有的身份系统。

**6.2. 权限**
MCP Host 负责控制其内部的 MCP Client 有权访问哪些 MCP Server 以及 Server 上的哪些工具和资源。服务器也必须在执行任何操作前验证客户端的权限。

**6.3. 数据隔离**
每个客户端会话都必须被隔离，以防止不同会话之间的信息泄露。

#### **7. 客户端实现要求 (以 Swift 为例)**

一份完整的 MCP 客户端实现，必须具备以下能力：

*   **7.1. 数据模型**：能够将 MCP 官方 JSON Schema 准确地映射为 Swift 的 `Codable` 数据结构。
*   **7.2. JSON-RPC 处理器**：一个健壮的模块，负责将 Swift 数据结构序列化为符合规范的 JSON-RPC 2.0 请求，以及将响应反序列化为 Swift 数据结构，并能正确处理 `result` 和 `error`。
*   **7.3. Stdio 传输处理器**：一个能够启动和管理子进程，并通过标准 I/O 管道（Pipes）进行通信的模块。该模块必须能正确实现 **4.1.2** 中定义的消息分帧和解析逻辑。
*   **7.4. HTTP/SSE 传输处理器**：一个能够发送 HTTP `POST` 请求并处理 `application/json` 响应的模块。同时，该模块必须能够处理 `text/event-stream` 响应，并从中正确解析出 SSE 事件流。
*   **7.5. 连接与会话管理**：能够管理与一个或多个 MCP Server 的连接生命周期，包括连接、断开和错误处理。
*   **7.6. 异步处理**：所有 I/O 操作（网络、进程通信）都必须以非阻塞的异步方式执行。
